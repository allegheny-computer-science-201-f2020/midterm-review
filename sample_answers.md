# CMPSC 201 Midterm Sample Questions and Answers

Here are examples of the kinds of questions that might be asked. This is not intended to be a sample exam. The actual exam will not be this long!

1. List the major steps in compilation.

  _Solution:_

  - Preprocessing
  - Lexical analysis
  - Syntax analysis
  - Semantic analysis
  - Intermediate code generation
  - Optimization
  - Final code generation

2. During which phase of computation does a compiler detect errors such as missing semicolons or unmatched parentheses?

  - (a) lexical analysis

  - (b) semantic analysis

  - (c) syntactic analysis

  - (d) none of the above

  _Solution_: (c)

3. Name one advantage of a compiled language over an interpreted language and one advantage of an interpreted language over a compiled language.

  _Solution_: Compiled languages are generally faster to execute, due to being able to perform more exhaustive optimizations during the compile process. One advantage of an interpreted language over a compiled language is that it may be more flexible. In some cases, it allows the user to make decisions based on previous program output. Most languages of course land somewhere between the two extremes.

4. For the regular expression `1+0*1*` give an example of two strings that can be generated by the regular expression and two that use the same alphabet but cannot be generated.

  _Solution_: It will accept 1 and 110\. It will not accept 01 and 011.

5. Consider the regular expression `10*|1+`. Describe the strings generated by this RE.

  _Solution_: All strings consisting of one 1 followed by zero or more 0s or just consisting of one more more 1s.

6. Given the following grammar (start symbol `S`, terminal symbols `a`, `+`, and `*`):

  `S -> S + E | E`

  `E -> E * a | a`

  Draw a parse tree or write out the derivation for the string `a * a + a` or explain why no such tree can be constructed.


  _Solution_:
  
  ```
     S
  /      |   \
  S    +    E
  /           \
  E             a
  /      |   \
  E    *    a
  |
  a
  ```

  | Rule | Derivation of the String |
  | --------- |:-------------:|
  | Start | S | 
  | S-> S + E | S + E | 
  | E-> a | S + a | 
  | S-> E | E + a | 
  | E-> E * a | E * a + a | 
  | E-> a | a * a + a | 

7. Consider the following syntax for expressions involving addition and field selection. Show that this grammar is ambiguous.

  ```
  expr -> expr + field
  expr -> field
  field -> expr . id
  field -> id
  ```

  _Solution:_  <img src="https://github.com/allegheny-computer-science-201-f2020/midterm-review/blob/main/images/tree.png" width="500" height="400">

8. Consider the grammar:

  ```
  E -> E + T
  E -> T
  T -> id
  ```

  Find all possible handles in the grammar above. Write them in terms of substrings.

  _Solution:_ `E + T`, `T`, `id`

9. Consider the following grammar. Use the shift-reduce algorithm to parse the input string `int id , id ;`. Show your steps.

  ```
  S -> T L;

  T -> int | float

  L -> L , id | id
  ```

  _Solution_:

  | Stack | Input | Parsing Action |
  | --------- |:-------------:|:-------------:|
  | $ | int id , id ; $ | Shift |
  | $ int | id , id ; $ | Reduce T -> int |
  | $ T | id , id ; $ | Shift |
  | $ T id | , id ; $ | Reduce L -> id |
  | $ T L | , id ; $ | Shift |
  | $ T L , | id ; $ | Shift |
  | $ T L , id | ; $ | Reduce L -> L , id |
  | $ T L | ; $ | Shift |
  | $ T L ; | $ | Reduce S -> T L |
  | $ S | $ | Accept |

10. Briefly explain the difference between the scope of a binding and the lifetime of a binding.

  _Solution_: The scope of a binding is where in the program the binding is active, while the lifetime of a binding which is the period of time from the creation to the destruction of the binding. Scope = where, lifetime = when.

11. For the following language features, specify its binding time.

  - Reserved keywords (for example, `main` in Java)

  _Solution_: language design

  - The specific type of a variable

  _Solution_: compile time

  - Internal representation of literals (for example, 10.5 and "foo bar")

  _Solution_: language implementation time

12. Consider the following two JavaScript programs. What is the output in each one. Why (consider the scope of `x`)?

  ```
  var x = 10;
  function f() {
     x = 20;
     if (x == 20) {
        var x = 30;
     }
  }
  f();
  console.log ("x = " + x);
  ```

  _Solution_: `x = 10`, since `x` is redeclared in `f` using `var` inside a function, limiting that scope to `f`.

  ```
  var x = 10;
  function f() {
     x = 20;
     if (x == 20) {
        x = 30;
     }
  }
  f();
  console.log ("x = " + x);
  ```

  _Solution_: `x = 30`, since `x` is not redeclared using `var`, making it a global variable.

13. Answer some questions about the following Java program; use the line numbers to identify particular statements or variables. Assume that Widget is a valid class defined in some other file.

   <img src="https://github.com/allegheny-computer-science-201-f2020/midterm-review/blob/main/images/widget.png" width="500" height="500">

  - Identify an example of a name binding that has a hole in its scope.

  _Solution_: The variable `p` defined on line 2 has a hole in its scope, in `func2` on line 12\. On line 2, `int p` is declared and on line 12, assigned the value 50\. However, in `func1()``, on line 5,`p`is redeclared and then on line 7 is assigned the value of`3 * 75 + x`. This represents a hole in the scope of the instance variable`p`.

  - Identify an example of a statement where stack allocation is performed.

  _Solution_: Stack allocation is performed on line 2 where the instance variables are declared.

  - Identify an example of a statement where heap allocation is performed.

  _Solution_: Heap allocation is performed on line 14 with the new keyword.

14. In the following program in an unspecified language, assume that we have two global variables `x` and `y`, set to 10 and 20 respectively, and four functions `main`, `a`, `b`, and `c`, some of which have local variables declared. Function `c` prints out the values of variables `x` and `y`.

  ```
  int x = 10, y = 20;
  main () {
     ...
  }
  function a() {
     int x = 30;
     ...
  }
  function b() {
     int y = 40;
     ...
  }
  function c() {
     print x, y;
  }
  ```

  - Assume that this program uses lexical scoping. If main calls function `a`, which calls function `b`, which calls `a`, which calls `c`, what values will be printed by `c`?

  _Solution_: `x = 10, y = 20`, because you look at the structural parent of c()

  - Now assume that this program uses dynamic scoping. If main calls function `a`, which calls function `b`, which calls `a`, which calls `c`, what values will be printed by `c`?

  _Solution_: `x = 30, y = 40`, because you look at the closest functional parents of `c()` that assigned `x` and `y`
